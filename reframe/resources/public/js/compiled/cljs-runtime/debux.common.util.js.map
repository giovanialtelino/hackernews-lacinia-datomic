{"version":3,"sources":["debux/common/util.cljc"],"mappings":"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","names":["debux.common.util/sequential-zip","root","clojure.zip/zipper","cljs.core/sequential?","cljs.core/identity","x","children","cljs.core/vector?","cljs.core/vec","debux.common.util/right-or-next","loc","temp__5733__auto__","right","clojure.zip/right","clojure.zip/node","rightmost","clojure.zip/down","clojure.zip/rightmost","clojure.zip/next","debux.common.util/auto-gensym-pattern","debux.common.util/anon-gensym-pattern","debux.common.util/named-gensym-pattern","debux.common.util/anon-param-pattern","debux.common.util/form-tree-seq","form","cljs.core/tree-seq","cljs.core/seq","debux.common.util/with-gensyms-names","mapping","gen-name","result","name","cljs.core/contains?","cljs.core/iterate","cljs.core/inc","p1__61670#","cljs.core.map","p1__61671#","cljs.core.filter","cljs.core/first","name-for","sym-name","groups","cljs.core/re-matches","cljs.core/second","cljs.core.reduce","new-name","cljs.core.assoc","p1__61673#","cljs.core/Symbol","cljs.core/namespace","cljs.core/name","p__61679","map__61680","cljs.core/PROTOCOL_SENTINEL","cljs.core.apply","cljs.core/hash-map","cljs.core.get","debux.common.util/with-symbols-names","context","refers","aliases","state","sym","cljs.core._EQ_","cljs.core.pr_str","p1__61677#","debux.common.util/tidy-macroexpanded-form","clojure.zip/end?","clojure.zip/root","clojure.zip/edit","cljs.core.symbol","debux.common.util/send-form!","re-frame.trace/is-trace-enabled?","new-trace__53011__auto__","cljs.core.merge","cljs.core.update","re-frame.trace/*current-trace*","cljs.core/merge","cljs.core.dissoc","debux.common.util/send-trace!","code-trace","code","cljs.core.get_in","cljs.core.conj","debux.common.util/indent-level*","cljs.core.atom","debux.common.util/reset-indent-level!","cljs.core/reset!","debux.common.util/print-seq-length*","debux.common.util/set-print-seq-length!","num","debux.common.util/cljs-env?","env","cljs.core/boolean","debux.common.util/vec->map","v","cljs.core/array-map","cljs.core.mapcat","cljs.core.sequence","cljs.core.concat","cljs.core/List","elm","cljs.core.keyword","debux.common.util/replace-&","clojure.walk/postwalk-replace","debux.common.util/take-n-if-seq","n","cljs.core/seq?","cljs.core.take","or__4126__auto__","cljs.core/deref","debux.common.util/truncate","s","cljs.core/count","debux.common.util/make-bars-","times","cljs.core/str","cljs.core.repeat","debux.common.util/make-bars","cljs.core/memoize","debux.common.util/prepend-bars","line","indent-level","debux.common.util/print-form-with-indent","cljs.core.println","cljs.core/flush","var_args","args__4742__auto__","len__4736__auto__","i__4737__auto__","argseq__4743__auto__","cljs.core/IndexedSeq","debux.common.util/form-header","p__61691","vec__61692","cljs.core.nth","seq61689","G__61690","cljs.core/next","self__4723__auto__","msg","and__4115__auto__","debux.common.util/prepend-blanks","lines","p1__61695#","cljs.core.mapv","debux.common.util/pprint-result-with-indent","res","sb__4667__auto__","goog.string/StringBuffer","*print-newline*-orig-val__61698","cljs.core/*print-newline*","*print-fn*-orig-val__61699","cljs.core/*print-fn*","*print-newline*-temp-val__61700","*print-fn*-temp-val__61701","x__4668__auto__","cljs.pprint.pprint","pprint","clojure.string/trim","clojure.string.split","p1__61696#","clojure.string.join","debux.common.util/insert-blank-line","debux.common.util/parse-opts","opts","acc","f","cljs.core/empty?","cljs.core/nnext","fexpr__61720","fexpr__61722","p__61723","vec__61724","debux.common.util/quote-val","k","debux.common.util/quote-vals","m","cljs.core.into","debux.common.util/include-recur?","G__61735","fexpr__61734","cljs.core.comp","cljs.core/set","cljs.core/flatten","debux.common.util/o-skip?","debux.common.util/spy-first","quoted-form","indent","js/Error","cljs.core/integer?","cljs.core.prn_str","G__61743","G__61744","debux.common.util/remove-d","debux.common.util/spy-last","G__61745","G__61746","debux.common.util/spy-comp","arg","G__61747","G__61748","debux.common.util/debux-skip-symbol?","debux.common.util/spy-first?","debux.common.util/third","coll","d-sym","node","clojure.zip/replace","cljs.core/last"],"sourcesContent":["(ns debux.common.util\n  \"Utilities common for clojure and clojurescript\"\n  (:refer-clojure :exclude [coll?])\n  (:require [clojure.string :as str]\n            [clojure.pprint :as pp]\n            [clojure.zip :as z]\n            [clojure.walk :as walk]\n            [cljs.analyzer.api :as ana]\n            [clojure.repl :as repl]\n            [re-frame.trace :as trace]))\n\n;;; zipper\n(defn sequential-zip [root]\n  (z/zipper sequential?\n            identity\n            (fn [x children]\n              (if (vector? x) (vec children) children))\n            root))\n\n(defn right-or-next [loc]\n  (if-let [right (z/right loc)]\n    ;; in case of (... (+ a b) c) or (... a b)\n    right\n    (if (sequential? (z/node loc))\n      (let [rightmost (-> loc z/down z/rightmost)]\n        (if (sequential? (z/node rightmost))\n          ;; in case of (... (+ a (* b c)))\n          (recur rightmost)\n\n          ;; in case of (... (+ a b))\n          (-> rightmost z/next)))\n\n      ;; in case of (... a)\n      (-> loc z/next))))\n\n\n;; Tidy up macroexpansions\n\n(def auto-gensym-pattern #\"(.*)__\\d+__auto__\")              ;; form#\n(def anon-gensym-pattern #\"G__\\d+\")                         ;; (gensym)\n(def named-gensym-pattern #\"(.*?)\\d{4,}\")                   ;; (gensym 'form), must match at least 4 numbers so we don't catch symbols with trailing numbers\n(def anon-param-pattern #\"p(\\d+)__\\d+#\")                    ;; #(%1 %2 %3)\n\n(defn form-tree-seq [form]\n  (tree-seq\n    sequential?\n    seq\n    form))\n\n(defn with-gensyms-names\n  \"Reverse gensym'd names to their original source form to make them easier to read.\"\n  [form mapping]\n  (let [gen-name (fn [result name]\n                   (if-not (contains? result (str name \"#\"))\n                     (str name \"#\")\n                     (->> (iterate inc 2)\n                          (map #(str name % \"#\"))\n                          (filter #(not (contains? result %)))\n                          (first))))\n        name-for (fn [result sym-name]\n                   (if-let [groups (re-matches auto-gensym-pattern sym-name)]\n                     (gen-name result (second groups))\n                     (if (re-matches anon-gensym-pattern sym-name)\n                       (gen-name result \"gensym\")\n                       (if-let [groups (re-matches named-gensym-pattern sym-name)]\n                         (gen-name result (second groups))\n                         (if-let [groups (re-matches anon-param-pattern sym-name)]\n                           (str \"%\" (second groups)))))))]\n    (reduce (fn [result sym-name]\n              (if (contains? result sym-name)\n                result\n                (if-let [new-name (name-for result sym-name)]\n                  (assoc result sym-name new-name)\n                  result)))\n            mapping\n            (->> (form-tree-seq form)\n                 (filter #(and (symbol? %) (nil? (namespace %))))\n                 (map name)))))\n\n(defn with-symbols-names\n  \"Tidy up fully qualified names that have aliases in the existing namespace.\"\n  ;; TODO: handle FQN's other than clojure.core\n  [form {:keys [context refers aliases] :as state} mapping]\n  (reduce (fn [result sym]\n            (if (= \"clojure.core\" (namespace sym))\n              (assoc result (pr-str sym) (name sym))\n              result))\n          mapping\n          (->> (form-tree-seq form)\n               ;; TODO: use qualified-symbol? once we are on Clojure 1.9\n               (filter #(and (symbol? %) (namespace %)))))\n\n  #_(reduce (fn [result sym]\n              (let [sym-ns (namespace sym)\n                    alias  (get aliases sym-ns)\n                    refers (get refers sym-ns)]\n                (cond\n                  ; Referred symbol, or from this ns\n                  (or (= :all (:refer refers))\n                      (contains? (:refer refers) (name sym))\n                      (= (context/namespace context) sym-ns))\n                  (assoc result (names/qualified-name sym) (name sym))\n                  ; Aliased symbol\n                  alias (assoc result (names/qualified-name sym) (str alias \\/ (name sym)))\n                  :else result)))\n            mapping\n            (->> (visible-tree-seq form)\n                 (filter #(and (psi/symbol? %) (namespace %))))))\n\n(defn tidy-macroexpanded-form\n  \"Takes a macroexpanded form and tidies it up to be more readable by\n  unmapping gensyms and replacing fully qualified namespaces with aliases\n  or nothing if the function is referred.\"\n  [form state]\n  ;; Mapping is a mapping of String:String which represent symbols\n  (let [mapping (->> {}\n                     (with-gensyms-names form)\n                     (with-symbols-names form state))]\n    (loop [loc (sequential-zip form)]\n      (if (z/end? loc)\n        (z/root loc)\n        (if (symbol? (z/node loc))\n          (recur (z/next (z/edit loc (fn [sym] (symbol (get mapping (pr-str sym) sym))))))\n          (recur (z/next loc)))))))\n\n;;\n\n(defn send-form! [form]\n  (trace/merge-trace! {:tags {:form form}}))\n\n(defn send-trace! [code-trace]\n  (let [code (get-in trace/*current-trace* [:tags :code] [])]\n    ;; TODO: also capture macroexpanded form? Might be useful in some cases?\n    (trace/merge-trace!\n      {:tags {:code (conj code {:form (tidy-macroexpanded-form (:form code-trace) {}) :result (:result code-trace) :indent-level (:indent-level code-trace)})}})))\n\n;;; For internal debugging\n(defmacro d\n  \"The internal macro to debug dbg macro.\n   <form any> a form to be evaluated\"\n  [form]\n  `(let [return# ~form]\n     (println \">> dbg_:\" (pr-str '~form) \"=>\\n\" (pr-str return#) \"<<\")\n     return#))\n\n\n;;; indent-level control\n(def indent-level* (atom 1))\n\n(defn reset-indent-level! []\n  (reset! indent-level* 1))\n\n\n;;; print-seq-length\n(def print-seq-length* (atom 100))\n\n(defn set-print-seq-length! [num]\n  (reset! print-seq-length* num))\n\n\n;;; general\n(defmacro read-source [sym]\n  `(-> (repl/source ~sym)\n       with-out-str\n       read-string))\n\n(defn cljs-env? [env]\n  (boolean (:ns env)))\n\n(defn vec->map\n  \"Transsub-forms a vector into an array-map with key/value pairs.\n  (def a 10)\n  (def b 20)\n  (vec-map [a b :c [30 40]])\n  => {:a 10 :b 20 ::c :c :[30 40] [30 40]}\"\n  [v]\n  (apply array-map\n         (mapcat (fn [elm]\n                   `[~(keyword (str elm)) ~elm])\n                 v)))\n\n(defn replace-& [v]\n  (walk/postwalk-replace {'& ''&} v))\n\n\n\n;;; symbol with namespace\n#?(:clj\n   (defn- var->symbol [v]\n     (let [m    (meta v)\n           ns   (str (ns-name (:ns m)))\n           name (str (:name m))]\n       (symbol ns name))))\n\n#?(:clj\n   (defn- ns-symbol-for-clj [sym]\n     (if-let [v (resolve sym)]\n       (var->symbol v)\n       sym)))\n\n#?(:clj\n   (defn- ns-symbol-for-cljs [sym env]\n     (if-let [meta (ana/resolve env sym)]\n       ;; normal symbol\n       (let [[ns name] (str/split (str (:name meta)) #\"/\")]\n         ;; The special symbol `.` must be handled in the following special symbol part.\n         ;; However, the special symbol `.` returns meta {:name / :ns nil}, which may be a bug.\n         (if (nil? ns)\n           sym\n           (symbol ns name)))\n       ;; special symbols except for `.`\n       sym)))\n\n#?(:clj\n   (defn ns-symbol [sym & [env]]\n     (if (symbol? sym)\n       (if (cljs-env? env)\n         (ns-symbol-for-cljs sym env)\n         (ns-symbol-for-clj sym))\n       sym)))\n\n\n;;; print\n(defn take-n-if-seq [n result]\n  (if (seq? result)\n    (take (or n @print-seq-length*) result)\n    result))\n\n(defn truncate [s]\n  (if (> (count s) 70)\n    (str (.substring s 0 70) \" ...\")\n    s))\n\n(defn- make-bars-\n  [times]\n  (apply str (repeat times \"|\")))\n\n(def make-bars (memoize make-bars-))\n\n(defn prepend-bars\n  [line indent-level]\n  (str (make-bars indent-level) \" \" line))\n\n(defn print-form-with-indent\n  [form indent-level]\n  ;; TODO: trace this information somehow\n  (println (prepend-bars form indent-level))\n  (flush))\n\n(defn form-header [form & [msg]]\n  (str (truncate (pr-str form))\n       (and msg (str \"   <\" msg \">\"))\n       \" =>\"))\n\n\n(defn prepend-blanks\n  [lines]\n  (mapv #(str \"  \" %) lines))\n\n(defn pprint-result-with-indent\n  [result indent-level]\n  ;; TODO: trace this information somehow\n  (let [res    result\n        result (with-out-str (pp/pprint res))\n        pprint (str/trim result)]\n    (println (->> (str/split pprint #\"\\n\")\n                  prepend-blanks\n                  (mapv #(prepend-bars % indent-level))\n                  (str/join \"\\n\")))\n    (flush)))\n\n(defn insert-blank-line []\n  (println \" \")\n  (flush))\n\n\n;;; parse options\n(defn parse-opts\n  [opts]\n  (loop [opts opts\n         acc  {}]\n    (let [f (first opts)\n          s (second opts)]\n      (cond\n        (empty? opts)\n        acc\n\n        (number? f)\n        (recur (next opts) (assoc acc :n f))\n\n        (string? f)\n        (recur (next opts) (assoc acc :msg f))\n\n        (= f :if)\n        (recur (nnext opts) (assoc acc :condition s))\n\n        ;;; for clojurescript\n        (= f :js)\n        (recur (next opts) (assoc acc :js true))\n\n        (#{:once :o} f)\n        (recur (next opts) (assoc acc :once true))\n\n        (#{:style :s} f)\n        (recur (nnext opts) (assoc acc :style s))\n\n        (= f :clog)\n        (recur (next opts) (assoc acc :clog true))))))\n\n\n;;; quote the value parts of a map\n(defn quote-val [[k v]]\n  `[~k '~v])\n\n(defn quote-vals [m]\n  (->> (map quote-val m)\n       (into {})))\n\n\n;;; for recur processing\n(defn include-recur? [form]\n  (((comp set flatten) form) 'recur))\n\n#?(:clj\n   (defn final-target? [sym targets env]\n     (let [ns-sym (ns-symbol sym env)]\n       (or (get targets ns-sym)\n           (some #(= % ns-sym)\n                 '[clojure.core/defn clojure.core/defn- clojure.core/fn\n                   cljs.core/defn cljs.core/defn- cljs.core/fn])))))\n\n(defn o-skip? [sym]\n  (= 'debux.common.macro-specs/o-skip sym))\n\n(declare remove-d)\n\n;;; spy functions\n(def spy-first\n  (fn [result quoted-form indent]\n    (assert (integer? indent) (str \"indent was not correctly replaced for form \" (prn-str quoted-form) \"\\nThis is a bug, please report it to https://github.com/Day8/re-frame-debux\"))\n    (send-trace! {:form (remove-d quoted-form 'dummy) :result result :indent-level indent})\n    ;(print-form-with-indent (form-header quoted-form) indent)\n    ;(pprint-result-with-indent (take-n-if-seq 100 result) indent)\n    result))\n\n(def spy-last\n  (fn [quoted-form indent result]\n    (assert (integer? indent) (str \"indent was not correctly replaced for form \" (prn-str quoted-form) \"\\nThis is a bug, please report it to https://github.com/Day8/re-frame-debux\"))\n    (send-trace! {:form (remove-d quoted-form 'dummy) :result result :indent-level indent})\n    ;(print-form-with-indent (form-header quoted-form) indent)\n    ;(pprint-result-with-indent (take-n-if-seq 100 result) indent)\n    result))\n\n(defn spy-comp [quoted-form indent form]\n  (fn [& arg]\n    (let [result (apply form arg)]\n      (assert (integer? indent) (str \"indent was not correctly replaced for form \" (prn-str quoted-form) \"\\nThis is a bug, please report it to https://github.com/Day8/re-frame-debux\"))\n      (send-trace! {:form (remove-d quoted-form 'dummy) :result result :indent-level indent})\n      ;(print-form-with-indent (form-header quoted-form) indent)\n      ;(pprint-result-with-indent (take-n-if-seq 100 result) indent)\n      result)))\n\n;; Remove trace info\n\n(defn debux-skip-symbol? [sym]\n  (contains? #{'debux.common.macro-specs/skip-outer\n               'debux.common.macro-specs/skip\n               'debux.common.macro-specs/o-skip}\n             sym))\n\n(defn spy-first? [sym]\n  (= 'debux.common.util/spy-first sym))\n\n(defn third [coll]\n  (first (next (next coll))))\n\n(defn remove-d [form d-sym]\n  ;; TODO: should we instead look to rewrite the quoted/spied forms\n  ;; at macro compile time, rather than filtering them out\n  ;; when the trace is being emitted?\n  (loop [loc (sequential-zip form)]\n    (let [node (z/node loc)]\n      ;(ut/d node)\n      (cond\n        (z/end? loc) (z/root loc)\n\n        ;; in case of (d ...)\n        (and (seq? node)\n             (or (= d-sym (first node))\n                 (debux-skip-symbol? (first node))\n                 (spy-first? (first node))))\n        ;; We take the third node, because the first two are\n        ;; (d <indent-level> ...)\n        (recur (z/replace loc (third node)))\n\n        ;; in case of spy-last\n        (and (seq? node)\n             (= `spy-last (first node)))\n        (recur (z/replace loc (last node)))\n\n        :else\n        (recur (z/next loc))))))\n"]}