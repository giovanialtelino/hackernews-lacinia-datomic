["^ ","~:resource-id",["~:shadow.build.classpath/resource","goog/fx/dom.js"],"~:js","goog.provide(\"goog.fx.dom\");\ngoog.provide(\"goog.fx.dom.BgColorTransform\");\ngoog.provide(\"goog.fx.dom.ColorTransform\");\ngoog.provide(\"goog.fx.dom.Fade\");\ngoog.provide(\"goog.fx.dom.FadeIn\");\ngoog.provide(\"goog.fx.dom.FadeInAndShow\");\ngoog.provide(\"goog.fx.dom.FadeOut\");\ngoog.provide(\"goog.fx.dom.FadeOutAndHide\");\ngoog.provide(\"goog.fx.dom.PredefinedEffect\");\ngoog.provide(\"goog.fx.dom.Resize\");\ngoog.provide(\"goog.fx.dom.ResizeHeight\");\ngoog.provide(\"goog.fx.dom.ResizeWidth\");\ngoog.provide(\"goog.fx.dom.Scroll\");\ngoog.provide(\"goog.fx.dom.Slide\");\ngoog.provide(\"goog.fx.dom.SlideFrom\");\ngoog.provide(\"goog.fx.dom.Swipe\");\ngoog.forwardDeclare(\"goog.events.EventHandler\");\ngoog.require(\"goog.color\");\ngoog.require(\"goog.events\");\ngoog.require(\"goog.fx.Animation\");\ngoog.require(\"goog.fx.Transition\");\ngoog.require(\"goog.style\");\ngoog.require(\"goog.style.bidi\");\n/**\n * @struct\n * @constructor\n * @extends {goog.fx.Animation}\n * @param {Element} element\n * @param {Array<number>} start\n * @param {Array<number>} end\n * @param {number} time\n * @param {Function=} opt_acc\n */\ngoog.fx.dom.PredefinedEffect = function(element, start, end, time, opt_acc) {\n  goog.fx.dom.PredefinedEffect.base(this, \"constructor\", start, end, time, opt_acc);\n  /** @type {Element} */ this.element = element;\n  /** @private @type {(boolean|undefined)} */ this.rightToLeft_;\n};\ngoog.inherits(goog.fx.dom.PredefinedEffect, goog.fx.Animation);\n/** @protected */ goog.fx.dom.PredefinedEffect.prototype.updateStyle = goog.nullFunction;\n/**\n * @return {boolean}\n */\ngoog.fx.dom.PredefinedEffect.prototype.isRightToLeft = function() {\n  if (this.rightToLeft_ === undefined) {\n    this.rightToLeft_ = goog.style.isRightToLeft(this.element);\n  }\n  return this.rightToLeft_;\n};\n/** @override */ goog.fx.dom.PredefinedEffect.prototype.onAnimate = function() {\n  this.updateStyle();\n  goog.fx.dom.PredefinedEffect.superClass_.onAnimate.call(this);\n};\n/** @override */ goog.fx.dom.PredefinedEffect.prototype.onEnd = function() {\n  this.updateStyle();\n  goog.fx.dom.PredefinedEffect.superClass_.onEnd.call(this);\n};\n/** @override */ goog.fx.dom.PredefinedEffect.prototype.onBegin = function() {\n  this.updateStyle();\n  goog.fx.dom.PredefinedEffect.superClass_.onBegin.call(this);\n};\n/**\n * @struct\n * @constructor\n * @extends {goog.fx.dom.PredefinedEffect}\n * @param {Element} element\n * @param {Array<number>} start\n * @param {Array<number>} end\n * @param {number} time\n * @param {Function=} opt_acc\n */\ngoog.fx.dom.Slide = function(element, start, end, time, opt_acc) {\n  if (start.length != 2 || end.length != 2) {\n    throw new Error(\"Start and end points must be 2D\");\n  }\n  goog.fx.dom.Slide.base(this, \"constructor\", element, start, end, time, opt_acc);\n};\ngoog.inherits(goog.fx.dom.Slide, goog.fx.dom.PredefinedEffect);\n/** @override */ goog.fx.dom.Slide.prototype.updateStyle = function() {\n  var pos = this.isRightPositioningForRtlEnabled() && this.isRightToLeft() ? \"right\" : \"left\";\n  this.element.style[pos] = Math.round(this.coords[0]) + \"px\";\n  this.element.style.top = Math.round(this.coords[1]) + \"px\";\n};\n/**\n * @struct\n * @constructor\n * @extends {goog.fx.dom.Slide}\n * @param {Element} element\n * @param {Array<number>} end\n * @param {number} time\n * @param {Function=} opt_acc\n */\ngoog.fx.dom.SlideFrom = function(element, end, time, opt_acc) {\n  var offsetLeft = /** @type {!HTMLElement} */ (element).offsetLeft;\n  var start = [offsetLeft, /** @type {!HTMLElement} */ (element).offsetTop];\n  goog.fx.dom.SlideFrom.base(this, \"constructor\", element, start, end, time, opt_acc);\n  /** @type {?Array<number>} */ this.startPoint;\n};\ngoog.inherits(goog.fx.dom.SlideFrom, goog.fx.dom.Slide);\n/** @override */ goog.fx.dom.SlideFrom.prototype.onBegin = function() {\n  var offsetLeft = this.isRightPositioningForRtlEnabled() ? goog.style.bidi.getOffsetStart(this.element) : /** @type {!HTMLElement} */ (this.element).offsetLeft;\n  this.startPoint = [offsetLeft, /** @type {!HTMLElement} */ (this.element).offsetTop];\n  goog.fx.dom.SlideFrom.superClass_.onBegin.call(this);\n};\n/**\n * @struct\n * @constructor\n * @extends {goog.fx.dom.PredefinedEffect}\n * @param {Element} element\n * @param {Array<number>} start\n * @param {Array<number>} end\n * @param {number} time\n * @param {Function=} opt_acc\n */\ngoog.fx.dom.Swipe = function(element, start, end, time, opt_acc) {\n  if (start.length != 2 || end.length != 2) {\n    throw new Error(\"Start and end points must be 2D\");\n  }\n  goog.fx.dom.Swipe.base(this, \"constructor\", element, start, end, time, opt_acc);\n  /** @private @type {number} */ this.maxWidth_ = Math.max(this.endPoint[0], this.startPoint[0]);\n  /** @private @type {number} */ this.maxHeight_ = Math.max(this.endPoint[1], this.startPoint[1]);\n};\ngoog.inherits(goog.fx.dom.Swipe, goog.fx.dom.PredefinedEffect);\n/** @protected @override */ goog.fx.dom.Swipe.prototype.updateStyle = function() {\n  var x = this.coords[0];\n  var y = this.coords[1];\n  this.clip_(Math.round(x), Math.round(y), this.maxWidth_, this.maxHeight_);\n  this.element.style.width = Math.round(x) + \"px\";\n  var marginX = this.isRightPositioningForRtlEnabled() && this.isRightToLeft() ? \"marginRight\" : \"marginLeft\";\n  this.element.style[marginX] = Math.round(x) - this.maxWidth_ + \"px\";\n  this.element.style.marginTop = Math.round(y) - this.maxHeight_ + \"px\";\n};\n/**\n * @private\n * @param {number} x\n * @param {number} y\n * @param {number} w\n * @param {number} h\n */\ngoog.fx.dom.Swipe.prototype.clip_ = function(x, y, w, h) {\n  this.element.style.clip = \"rect(\" + (h - y) + \"px \" + w + \"px \" + h + \"px \" + (w - x) + \"px)\";\n};\n/**\n * @struct\n * @constructor\n * @extends {goog.fx.dom.PredefinedEffect}\n * @param {Element} element\n * @param {Array<number>} start\n * @param {Array<number>} end\n * @param {number} time\n * @param {Function=} opt_acc\n */\ngoog.fx.dom.Scroll = function(element, start, end, time, opt_acc) {\n  if (start.length != 2 || end.length != 2) {\n    throw new Error(\"Start and end points must be 2D\");\n  }\n  goog.fx.dom.Scroll.base(this, \"constructor\", element, start, end, time, opt_acc);\n};\ngoog.inherits(goog.fx.dom.Scroll, goog.fx.dom.PredefinedEffect);\n/** @protected @override */ goog.fx.dom.Scroll.prototype.updateStyle = function() {\n  if (this.isRightPositioningForRtlEnabled()) {\n    goog.style.bidi.setScrollOffset(this.element, Math.round(this.coords[0]));\n  } else {\n    this.element.scrollLeft = Math.round(this.coords[0]);\n  }\n  this.element.scrollTop = Math.round(this.coords[1]);\n};\n/**\n * @struct\n * @constructor\n * @extends {goog.fx.dom.PredefinedEffect}\n * @param {Element} element\n * @param {Array<number>} start\n * @param {Array<number>} end\n * @param {number} time\n * @param {Function=} opt_acc\n */\ngoog.fx.dom.Resize = function(element, start, end, time, opt_acc) {\n  if (start.length != 2 || end.length != 2) {\n    throw new Error(\"Start and end points must be 2D\");\n  }\n  goog.fx.dom.Resize.base(this, \"constructor\", element, start, end, time, opt_acc);\n};\ngoog.inherits(goog.fx.dom.Resize, goog.fx.dom.PredefinedEffect);\n/** @protected @override */ goog.fx.dom.Resize.prototype.updateStyle = function() {\n  this.element.style.width = Math.round(this.coords[0]) + \"px\";\n  this.element.style.height = Math.round(this.coords[1]) + \"px\";\n};\n/**\n * @struct\n * @constructor\n * @extends {goog.fx.dom.PredefinedEffect}\n * @param {Element} element\n * @param {number} start\n * @param {number} end\n * @param {number} time\n * @param {Function=} opt_acc\n */\ngoog.fx.dom.ResizeWidth = function(element, start, end, time, opt_acc) {\n  goog.fx.dom.ResizeWidth.base(this, \"constructor\", element, [start], [end], time, opt_acc);\n};\ngoog.inherits(goog.fx.dom.ResizeWidth, goog.fx.dom.PredefinedEffect);\n/** @protected @override */ goog.fx.dom.ResizeWidth.prototype.updateStyle = function() {\n  this.element.style.width = Math.round(this.coords[0]) + \"px\";\n};\n/**\n * @struct\n * @constructor\n * @extends {goog.fx.dom.PredefinedEffect}\n * @param {Element} element\n * @param {number} start\n * @param {number} end\n * @param {number} time\n * @param {Function=} opt_acc\n */\ngoog.fx.dom.ResizeHeight = function(element, start, end, time, opt_acc) {\n  goog.fx.dom.ResizeHeight.base(this, \"constructor\", element, [start], [end], time, opt_acc);\n};\ngoog.inherits(goog.fx.dom.ResizeHeight, goog.fx.dom.PredefinedEffect);\n/** @protected @override */ goog.fx.dom.ResizeHeight.prototype.updateStyle = function() {\n  this.element.style.height = Math.round(this.coords[0]) + \"px\";\n};\n/**\n * @struct\n * @constructor\n * @extends {goog.fx.dom.PredefinedEffect}\n * @param {Element} element\n * @param {(Array<number>|number)} start\n * @param {(Array<number>|number)} end\n * @param {number} time\n * @param {Function=} opt_acc\n */\ngoog.fx.dom.Fade = function(element, start, end, time, opt_acc) {\n  if (typeof start === \"number\") {\n    start = [start];\n  }\n  if (typeof end === \"number\") {\n    end = [end];\n  }\n  goog.fx.dom.Fade.base(this, \"constructor\", element, start, end, time, opt_acc);\n  if (start.length != 1 || end.length != 1) {\n    throw new Error(\"Start and end points must be 1D\");\n  }\n  /** @private @type {number} */ this.lastOpacityUpdate_ = goog.fx.dom.Fade.OPACITY_UNSET_;\n};\ngoog.inherits(goog.fx.dom.Fade, goog.fx.dom.PredefinedEffect);\n/** @private @type {number} */ goog.fx.dom.Fade.TOLERANCE_ = 1.0 / 1024;\n/** @private @type {number} */ goog.fx.dom.Fade.OPACITY_UNSET_ = -1;\n/** @protected @override */ goog.fx.dom.Fade.prototype.updateStyle = function() {\n  var opacity = this.coords[0];\n  var delta = Math.abs(opacity - this.lastOpacityUpdate_);\n  if (delta >= goog.fx.dom.Fade.TOLERANCE_) {\n    goog.style.setOpacity(this.element, opacity);\n    this.lastOpacityUpdate_ = opacity;\n  }\n};\n/** @override */ goog.fx.dom.Fade.prototype.onBegin = function() {\n  this.lastOpacityUpdate_ = goog.fx.dom.Fade.OPACITY_UNSET_;\n  goog.fx.dom.Fade.base(this, \"onBegin\");\n};\n/** @override */ goog.fx.dom.Fade.prototype.onEnd = function() {\n  this.lastOpacityUpdate_ = goog.fx.dom.Fade.OPACITY_UNSET_;\n  goog.fx.dom.Fade.base(this, \"onEnd\");\n};\ngoog.fx.dom.Fade.prototype.show = function() {\n  this.element.style.display = \"\";\n};\ngoog.fx.dom.Fade.prototype.hide = function() {\n  this.element.style.display = \"none\";\n};\n/**\n * @struct\n * @constructor\n * @extends {goog.fx.dom.Fade}\n * @param {Element} element\n * @param {number} time\n * @param {Function=} opt_acc\n */\ngoog.fx.dom.FadeOut = function(element, time, opt_acc) {\n  goog.fx.dom.FadeOut.base(this, \"constructor\", element, 1, 0, time, opt_acc);\n};\ngoog.inherits(goog.fx.dom.FadeOut, goog.fx.dom.Fade);\n/**\n * @struct\n * @constructor\n * @extends {goog.fx.dom.Fade}\n * @param {Element} element\n * @param {number} time\n * @param {Function=} opt_acc\n */\ngoog.fx.dom.FadeIn = function(element, time, opt_acc) {\n  goog.fx.dom.FadeIn.base(this, \"constructor\", element, 0, 1, time, opt_acc);\n};\ngoog.inherits(goog.fx.dom.FadeIn, goog.fx.dom.Fade);\n/**\n * @struct\n * @constructor\n * @extends {goog.fx.dom.Fade}\n * @param {Element} element\n * @param {number} time\n * @param {Function=} opt_acc\n */\ngoog.fx.dom.FadeOutAndHide = function(element, time, opt_acc) {\n  goog.fx.dom.FadeOutAndHide.base(this, \"constructor\", element, 1, 0, time, opt_acc);\n};\ngoog.inherits(goog.fx.dom.FadeOutAndHide, goog.fx.dom.Fade);\n/** @override */ goog.fx.dom.FadeOutAndHide.prototype.onBegin = function() {\n  this.show();\n  goog.fx.dom.FadeOutAndHide.superClass_.onBegin.call(this);\n};\n/** @override */ goog.fx.dom.FadeOutAndHide.prototype.onEnd = function() {\n  this.hide();\n  goog.fx.dom.FadeOutAndHide.superClass_.onEnd.call(this);\n};\n/**\n * @struct\n * @constructor\n * @extends {goog.fx.dom.Fade}\n * @param {Element} element\n * @param {number} time\n * @param {Function=} opt_acc\n */\ngoog.fx.dom.FadeInAndShow = function(element, time, opt_acc) {\n  goog.fx.dom.FadeInAndShow.base(this, \"constructor\", element, 0, 1, time, opt_acc);\n};\ngoog.inherits(goog.fx.dom.FadeInAndShow, goog.fx.dom.Fade);\n/** @override */ goog.fx.dom.FadeInAndShow.prototype.onBegin = function() {\n  this.show();\n  goog.fx.dom.FadeInAndShow.superClass_.onBegin.call(this);\n};\n/**\n * @struct\n * @constructor\n * @extends {goog.fx.dom.PredefinedEffect}\n * @param {Element} element\n * @param {Array<number>} start\n * @param {Array<number>} end\n * @param {number} time\n * @param {Function=} opt_acc\n */\ngoog.fx.dom.BgColorTransform = function(element, start, end, time, opt_acc) {\n  if (start.length != 3 || end.length != 3) {\n    throw new Error(\"Start and end points must be 3D\");\n  }\n  goog.fx.dom.BgColorTransform.base(this, \"constructor\", element, start, end, time, opt_acc);\n};\ngoog.inherits(goog.fx.dom.BgColorTransform, goog.fx.dom.PredefinedEffect);\ngoog.fx.dom.BgColorTransform.prototype.setColor = function() {\n  var coordsAsInts = [];\n  for (var i = 0; i < this.coords.length; i++) {\n    coordsAsInts[i] = Math.round(this.coords[i]);\n  }\n  var color = \"rgb(\" + coordsAsInts.join(\",\") + \")\";\n  this.element.style.backgroundColor = color;\n};\n/** @override */ goog.fx.dom.BgColorTransform.prototype.updateStyle = function() {\n  this.setColor();\n};\n/**\n * @param {Element} element\n * @param {Array<number>} start\n * @param {number} time\n * @param {goog.events.EventHandler=} opt_eventHandler\n */\ngoog.fx.dom.bgColorFadeIn = function(element, start, time, opt_eventHandler) {\n  var initialBgColor = element.style.backgroundColor || \"\";\n  var computedBgColor = goog.style.getBackgroundColor(element);\n  var end;\n  if (computedBgColor && computedBgColor != \"transparent\" && computedBgColor != \"rgba(0, 0, 0, 0)\") {\n    end = goog.color.hexToRgb(goog.color.parse(computedBgColor).hex);\n  } else {\n    end = [255, 255, 255];\n  }\n  var anim = new goog.fx.dom.BgColorTransform(element, start, end, time);\n  function setBgColor() {\n    element.style.backgroundColor = initialBgColor;\n  }\n  if (opt_eventHandler) {\n    opt_eventHandler.listen(anim, goog.fx.Transition.EventType.END, setBgColor);\n  } else {\n    goog.events.listen(anim, goog.fx.Transition.EventType.END, setBgColor);\n  }\n  anim.play();\n};\n/**\n * @struct\n * @constructor\n * @extends {goog.fx.dom.PredefinedEffect}\n * @param {Element} element\n * @param {Array<number>} start\n * @param {Array<number>} end\n * @param {number} time\n * @param {Function=} opt_acc\n */\ngoog.fx.dom.ColorTransform = function(element, start, end, time, opt_acc) {\n  if (start.length != 3 || end.length != 3) {\n    throw new Error(\"Start and end points must be 3D\");\n  }\n  goog.fx.dom.ColorTransform.base(this, \"constructor\", element, start, end, time, opt_acc);\n};\ngoog.inherits(goog.fx.dom.ColorTransform, goog.fx.dom.PredefinedEffect);\n/** @protected @override */ goog.fx.dom.ColorTransform.prototype.updateStyle = function() {\n  var coordsAsInts = [];\n  for (var i = 0; i < this.coords.length; i++) {\n    coordsAsInts[i] = Math.round(this.coords[i]);\n  }\n  var color = \"rgb(\" + coordsAsInts.join(\",\") + \")\";\n  this.element.style.color = color;\n};\n","~:source","// Copyright 2005 The Closure Library Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS-IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/**\n * @fileoverview Predefined DHTML animations such as slide, resize and fade.\n *\n * @see ../demos/effects.html\n */\n\ngoog.provide('goog.fx.dom');\ngoog.provide('goog.fx.dom.BgColorTransform');\ngoog.provide('goog.fx.dom.ColorTransform');\ngoog.provide('goog.fx.dom.Fade');\ngoog.provide('goog.fx.dom.FadeIn');\ngoog.provide('goog.fx.dom.FadeInAndShow');\ngoog.provide('goog.fx.dom.FadeOut');\ngoog.provide('goog.fx.dom.FadeOutAndHide');\ngoog.provide('goog.fx.dom.PredefinedEffect');\ngoog.provide('goog.fx.dom.Resize');\ngoog.provide('goog.fx.dom.ResizeHeight');\ngoog.provide('goog.fx.dom.ResizeWidth');\ngoog.provide('goog.fx.dom.Scroll');\ngoog.provide('goog.fx.dom.Slide');\ngoog.provide('goog.fx.dom.SlideFrom');\ngoog.provide('goog.fx.dom.Swipe');\n\ngoog.forwardDeclare('goog.events.EventHandler');\ngoog.require('goog.color');\ngoog.require('goog.events');\ngoog.require('goog.fx.Animation');\ngoog.require('goog.fx.Transition');\ngoog.require('goog.style');\ngoog.require('goog.style.bidi');\n\n\n\n/**\n * Abstract class that provides reusable functionality for predefined animations\n * that manipulate a single DOM element\n *\n * @param {Element} element Dom Node to be used in the animation.\n * @param {Array<number>} start Array for start coordinates.\n * @param {Array<number>} end Array for end coordinates.\n * @param {number} time Length of animation in milliseconds.\n * @param {Function=} opt_acc Acceleration function, returns 0-1 for inputs 0-1.\n * @extends {goog.fx.Animation}\n * @constructor\n * @struct\n */\ngoog.fx.dom.PredefinedEffect = function(element, start, end, time, opt_acc) {\n  goog.fx.dom.PredefinedEffect.base(\n      this, 'constructor', start, end, time, opt_acc);\n\n  /**\n   * DOM Node that will be used in the animation\n   * @type {Element}\n   */\n  this.element = element;\n\n  /**\n   * Whether the element is rendered right-to-left. We cache this here for\n   * efficiency.\n   * @private {boolean|undefined}\n   */\n  this.rightToLeft_;\n};\ngoog.inherits(goog.fx.dom.PredefinedEffect, goog.fx.Animation);\n\n\n/**\n * Called to update the style of the element.\n * @protected\n */\ngoog.fx.dom.PredefinedEffect.prototype.updateStyle = goog.nullFunction;\n\n\n/**\n * Whether the DOM element being manipulated is rendered right-to-left.\n * @return {boolean} True if the DOM element is rendered right-to-left, false\n *     otherwise.\n */\ngoog.fx.dom.PredefinedEffect.prototype.isRightToLeft = function() {\n  if (this.rightToLeft_ === undefined) {\n    this.rightToLeft_ = goog.style.isRightToLeft(this.element);\n  }\n  return this.rightToLeft_;\n};\n\n\n/** @override */\ngoog.fx.dom.PredefinedEffect.prototype.onAnimate = function() {\n  this.updateStyle();\n  goog.fx.dom.PredefinedEffect.superClass_.onAnimate.call(this);\n};\n\n\n/** @override */\ngoog.fx.dom.PredefinedEffect.prototype.onEnd = function() {\n  this.updateStyle();\n  goog.fx.dom.PredefinedEffect.superClass_.onEnd.call(this);\n};\n\n\n/** @override */\ngoog.fx.dom.PredefinedEffect.prototype.onBegin = function() {\n  this.updateStyle();\n  goog.fx.dom.PredefinedEffect.superClass_.onBegin.call(this);\n};\n\n\n\n/**\n * Creates an animation object that will slide an element from A to B.  (This\n * in effect automatically sets up the onanimate event for an Animation object)\n *\n * Start and End should be 2 dimensional arrays\n *\n * @param {Element} element Dom Node to be used in the animation.\n * @param {Array<number>} start 2D array for start coordinates (X, Y).\n * @param {Array<number>} end 2D array for end coordinates (X, Y).\n * @param {number} time Length of animation in milliseconds.\n * @param {Function=} opt_acc Acceleration function, returns 0-1 for inputs 0-1.\n * @extends {goog.fx.dom.PredefinedEffect}\n * @constructor\n * @struct\n */\ngoog.fx.dom.Slide = function(element, start, end, time, opt_acc) {\n  if (start.length != 2 || end.length != 2) {\n    throw new Error('Start and end points must be 2D');\n  }\n  goog.fx.dom.Slide.base(\n      this, 'constructor', element, start, end, time, opt_acc);\n};\ngoog.inherits(goog.fx.dom.Slide, goog.fx.dom.PredefinedEffect);\n\n\n/** @override */\ngoog.fx.dom.Slide.prototype.updateStyle = function() {\n  var pos = (this.isRightPositioningForRtlEnabled() && this.isRightToLeft()) ?\n      'right' :\n      'left';\n  this.element.style[pos] = Math.round(this.coords[0]) + 'px';\n  this.element.style.top = Math.round(this.coords[1]) + 'px';\n};\n\n\n\n/**\n * Slides an element from its current position.\n *\n * @param {Element} element DOM node to be used in the animation.\n * @param {Array<number>} end 2D array for end coordinates (X, Y).\n * @param {number} time Length of animation in milliseconds.\n * @param {Function=} opt_acc Acceleration function, returns 0-1 for inputs 0-1.\n * @extends {goog.fx.dom.Slide}\n * @constructor\n * @struct\n */\ngoog.fx.dom.SlideFrom = function(element, end, time, opt_acc) {\n  var offsetLeft = /** @type {!HTMLElement} */ (element).offsetLeft;\n  var start = [offsetLeft, /** @type {!HTMLElement} */ (element).offsetTop];\n  goog.fx.dom.SlideFrom.base(\n      this, 'constructor', element, start, end, time, opt_acc);\n  /** @type {?Array<number>} */\n  this.startPoint;\n};\ngoog.inherits(goog.fx.dom.SlideFrom, goog.fx.dom.Slide);\n\n\n/** @override */\ngoog.fx.dom.SlideFrom.prototype.onBegin = function() {\n  var offsetLeft = this.isRightPositioningForRtlEnabled() ?\n      goog.style.bidi.getOffsetStart(this.element) :\n      /** @type {!HTMLElement} */ (this.element).offsetLeft;\n  this.startPoint = [\n    offsetLeft,\n    /** @type {!HTMLElement} */ (this.element).offsetTop\n  ];\n  goog.fx.dom.SlideFrom.superClass_.onBegin.call(this);\n};\n\n\n\n/**\n * Creates an animation object that will slide an element into its final size.\n * Requires that the element is absolutely positioned.\n *\n * @param {Element} element Dom Node to be used in the animation.\n * @param {Array<number>} start 2D array for start size (W, H).\n * @param {Array<number>} end 2D array for end size (W, H).\n * @param {number} time Length of animation in milliseconds.\n * @param {Function=} opt_acc Acceleration function, returns 0-1 for inputs 0-1.\n * @extends {goog.fx.dom.PredefinedEffect}\n * @constructor\n * @struct\n */\ngoog.fx.dom.Swipe = function(element, start, end, time, opt_acc) {\n  if (start.length != 2 || end.length != 2) {\n    throw new Error('Start and end points must be 2D');\n  }\n  goog.fx.dom.Swipe.base(\n      this, 'constructor', element, start, end, time, opt_acc);\n\n  /**\n   * Maximum width for element.\n   * @type {number}\n   * @private\n   */\n  this.maxWidth_ = Math.max(this.endPoint[0], this.startPoint[0]);\n\n  /**\n   * Maximum height for element.\n   * @type {number}\n   * @private\n   */\n  this.maxHeight_ = Math.max(this.endPoint[1], this.startPoint[1]);\n};\ngoog.inherits(goog.fx.dom.Swipe, goog.fx.dom.PredefinedEffect);\n\n\n/**\n * Animation event handler that will resize an element by setting its width,\n * height and clipping.\n * @protected\n * @override\n */\ngoog.fx.dom.Swipe.prototype.updateStyle = function() {\n  var x = this.coords[0];\n  var y = this.coords[1];\n  this.clip_(Math.round(x), Math.round(y), this.maxWidth_, this.maxHeight_);\n  this.element.style.width = Math.round(x) + 'px';\n  var marginX =\n      (this.isRightPositioningForRtlEnabled() && this.isRightToLeft()) ?\n      'marginRight' :\n      'marginLeft';\n\n  this.element.style[marginX] = Math.round(x) - this.maxWidth_ + 'px';\n  this.element.style.marginTop = Math.round(y) - this.maxHeight_ + 'px';\n};\n\n\n/**\n * Helper function for setting element clipping.\n * @param {number} x Current element width.\n * @param {number} y Current element height.\n * @param {number} w Maximum element width.\n * @param {number} h Maximum element height.\n * @private\n */\ngoog.fx.dom.Swipe.prototype.clip_ = function(x, y, w, h) {\n  this.element.style.clip =\n      'rect(' + (h - y) + 'px ' + w + 'px ' + h + 'px ' + (w - x) + 'px)';\n};\n\n\n\n/**\n * Creates an animation object that will scroll an element from A to B.\n *\n * Start and End should be 2 dimensional arrays\n *\n * @param {Element} element Dom Node to be used in the animation.\n * @param {Array<number>} start 2D array for start scroll left and top.\n * @param {Array<number>} end 2D array for end scroll left and top.\n * @param {number} time Length of animation in milliseconds.\n * @param {Function=} opt_acc Acceleration function, returns 0-1 for inputs 0-1.\n * @extends {goog.fx.dom.PredefinedEffect}\n * @constructor\n * @struct\n */\ngoog.fx.dom.Scroll = function(element, start, end, time, opt_acc) {\n  if (start.length != 2 || end.length != 2) {\n    throw new Error('Start and end points must be 2D');\n  }\n  goog.fx.dom.Scroll.base(\n      this, 'constructor', element, start, end, time, opt_acc);\n};\ngoog.inherits(goog.fx.dom.Scroll, goog.fx.dom.PredefinedEffect);\n\n\n/**\n * Animation event handler that will set the scroll position of an element.\n * @protected\n * @override\n */\ngoog.fx.dom.Scroll.prototype.updateStyle = function() {\n  if (this.isRightPositioningForRtlEnabled()) {\n    goog.style.bidi.setScrollOffset(this.element, Math.round(this.coords[0]));\n  } else {\n    this.element.scrollLeft = Math.round(this.coords[0]);\n  }\n  this.element.scrollTop = Math.round(this.coords[1]);\n};\n\n\n\n/**\n * Creates an animation object that will resize an element between two widths\n * and heights.\n *\n * Start and End should be 2 dimensional arrays\n *\n * @param {Element} element Dom Node to be used in the animation.\n * @param {Array<number>} start 2D array for start width and height.\n * @param {Array<number>} end 2D array for end width and height.\n * @param {number} time Length of animation in milliseconds.\n * @param {Function=} opt_acc Acceleration function, returns 0-1 for inputs 0-1.\n * @extends {goog.fx.dom.PredefinedEffect}\n * @constructor\n * @struct\n */\ngoog.fx.dom.Resize = function(element, start, end, time, opt_acc) {\n  if (start.length != 2 || end.length != 2) {\n    throw new Error('Start and end points must be 2D');\n  }\n  goog.fx.dom.Resize.base(\n      this, 'constructor', element, start, end, time, opt_acc);\n};\ngoog.inherits(goog.fx.dom.Resize, goog.fx.dom.PredefinedEffect);\n\n\n/**\n * Animation event handler that will resize an element by setting its width and\n * height.\n * @protected\n * @override\n */\ngoog.fx.dom.Resize.prototype.updateStyle = function() {\n  this.element.style.width = Math.round(this.coords[0]) + 'px';\n  this.element.style.height = Math.round(this.coords[1]) + 'px';\n};\n\n\n\n/**\n * Creates an animation object that will resize an element between two widths\n *\n * Start and End should be numbers\n *\n * @param {Element} element Dom Node to be used in the animation.\n * @param {number} start Start width.\n * @param {number} end End width.\n * @param {number} time Length of animation in milliseconds.\n * @param {Function=} opt_acc Acceleration function, returns 0-1 for inputs 0-1.\n * @extends {goog.fx.dom.PredefinedEffect}\n * @constructor\n * @struct\n */\ngoog.fx.dom.ResizeWidth = function(element, start, end, time, opt_acc) {\n  goog.fx.dom.ResizeWidth.base(\n      this, 'constructor', element, [start], [end], time, opt_acc);\n};\ngoog.inherits(goog.fx.dom.ResizeWidth, goog.fx.dom.PredefinedEffect);\n\n\n/**\n * Animation event handler that will resize an element by setting its width.\n * @protected\n * @override\n */\ngoog.fx.dom.ResizeWidth.prototype.updateStyle = function() {\n  this.element.style.width = Math.round(this.coords[0]) + 'px';\n};\n\n\n\n/**\n * Creates an animation object that will resize an element between two heights\n *\n * Start and End should be numbers\n *\n * @param {Element} element Dom Node to be used in the animation.\n * @param {number} start Start height.\n * @param {number} end End height.\n * @param {number} time Length of animation in milliseconds.\n * @param {Function=} opt_acc Acceleration function, returns 0-1 for inputs 0-1.\n * @extends {goog.fx.dom.PredefinedEffect}\n * @constructor\n * @struct\n */\ngoog.fx.dom.ResizeHeight = function(element, start, end, time, opt_acc) {\n  goog.fx.dom.ResizeHeight.base(\n      this, 'constructor', element, [start], [end], time, opt_acc);\n};\ngoog.inherits(goog.fx.dom.ResizeHeight, goog.fx.dom.PredefinedEffect);\n\n\n/**\n * Animation event handler that will resize an element by setting its height.\n * @protected\n * @override\n */\ngoog.fx.dom.ResizeHeight.prototype.updateStyle = function() {\n  this.element.style.height = Math.round(this.coords[0]) + 'px';\n};\n\n\n\n/**\n * Creates an animation object that fades the opacity of an element between two\n * limits.\n *\n * Start and End should be floats between 0 and 1\n *\n * @param {Element} element Dom Node to be used in the animation.\n * @param {Array<number>|number} start 1D Array or Number with start opacity.\n * @param {Array<number>|number} end 1D Array or Number for end opacity.\n * @param {number} time Length of animation in milliseconds.\n * @param {Function=} opt_acc Acceleration function, returns 0-1 for inputs 0-1.\n * @extends {goog.fx.dom.PredefinedEffect}\n * @constructor\n * @struct\n */\ngoog.fx.dom.Fade = function(element, start, end, time, opt_acc) {\n  if (typeof start === 'number') start = [start];\n  if (typeof end === 'number') end = [end];\n\n  goog.fx.dom.Fade.base(\n      this, 'constructor', element, start, end, time, opt_acc);\n\n  if (start.length != 1 || end.length != 1) {\n    throw new Error('Start and end points must be 1D');\n  }\n\n  /**\n   * The last opacity we set, or -1 for not set.\n   * @private {number}\n   */\n  this.lastOpacityUpdate_ = goog.fx.dom.Fade.OPACITY_UNSET_;\n};\ngoog.inherits(goog.fx.dom.Fade, goog.fx.dom.PredefinedEffect);\n\n\n/**\n * The quantization of opacity values to use.\n * @private {number}\n */\ngoog.fx.dom.Fade.TOLERANCE_ = 1.0 / 0x400;  // 10-bit color\n\n\n/**\n * Value indicating that the opacity must be set on next update.\n * @private {number}\n */\ngoog.fx.dom.Fade.OPACITY_UNSET_ = -1;\n\n\n/**\n * Animation event handler that will set the opacity of an element.\n * @protected\n * @override\n */\ngoog.fx.dom.Fade.prototype.updateStyle = function() {\n  var opacity = this.coords[0];\n  var delta = Math.abs(opacity - this.lastOpacityUpdate_);\n  // In order to keep eager browsers from over-rendering, only update\n  // on a potentially visible change in opacity.\n  if (delta >= goog.fx.dom.Fade.TOLERANCE_) {\n    goog.style.setOpacity(this.element, opacity);\n    this.lastOpacityUpdate_ = opacity;\n  }\n};\n\n\n/** @override */\ngoog.fx.dom.Fade.prototype.onBegin = function() {\n  this.lastOpacityUpdate_ = goog.fx.dom.Fade.OPACITY_UNSET_;\n  goog.fx.dom.Fade.base(this, 'onBegin');\n};\n\n\n/** @override */\ngoog.fx.dom.Fade.prototype.onEnd = function() {\n  this.lastOpacityUpdate_ = goog.fx.dom.Fade.OPACITY_UNSET_;\n  goog.fx.dom.Fade.base(this, 'onEnd');\n};\n\n\n/**\n * Animation event handler that will show the element.\n */\ngoog.fx.dom.Fade.prototype.show = function() {\n  this.element.style.display = '';\n};\n\n\n/**\n * Animation event handler that will hide the element\n */\ngoog.fx.dom.Fade.prototype.hide = function() {\n  this.element.style.display = 'none';\n};\n\n\n\n/**\n * Fades an element out from full opacity to completely transparent.\n *\n * @param {Element} element Dom Node to be used in the animation.\n * @param {number} time Length of animation in milliseconds.\n * @param {Function=} opt_acc Acceleration function, returns 0-1 for inputs 0-1.\n * @extends {goog.fx.dom.Fade}\n * @constructor\n * @struct\n */\ngoog.fx.dom.FadeOut = function(element, time, opt_acc) {\n  goog.fx.dom.FadeOut.base(this, 'constructor', element, 1, 0, time, opt_acc);\n};\ngoog.inherits(goog.fx.dom.FadeOut, goog.fx.dom.Fade);\n\n\n\n/**\n * Fades an element in from completely transparent to fully opacity.\n *\n * @param {Element} element Dom Node to be used in the animation.\n * @param {number} time Length of animation in milliseconds.\n * @param {Function=} opt_acc Acceleration function, returns 0-1 for inputs 0-1.\n * @extends {goog.fx.dom.Fade}\n * @constructor\n * @struct\n */\ngoog.fx.dom.FadeIn = function(element, time, opt_acc) {\n  goog.fx.dom.FadeIn.base(this, 'constructor', element, 0, 1, time, opt_acc);\n};\ngoog.inherits(goog.fx.dom.FadeIn, goog.fx.dom.Fade);\n\n\n\n/**\n * Fades an element out from full opacity to completely transparent and then\n * sets the display to 'none'\n *\n * @param {Element} element Dom Node to be used in the animation.\n * @param {number} time Length of animation in milliseconds.\n * @param {Function=} opt_acc Acceleration function, returns 0-1 for inputs 0-1.\n * @extends {goog.fx.dom.Fade}\n * @constructor\n * @struct\n */\ngoog.fx.dom.FadeOutAndHide = function(element, time, opt_acc) {\n  goog.fx.dom.FadeOutAndHide.base(\n      this, 'constructor', element, 1, 0, time, opt_acc);\n};\ngoog.inherits(goog.fx.dom.FadeOutAndHide, goog.fx.dom.Fade);\n\n\n/** @override */\ngoog.fx.dom.FadeOutAndHide.prototype.onBegin = function() {\n  this.show();\n  goog.fx.dom.FadeOutAndHide.superClass_.onBegin.call(this);\n};\n\n\n/** @override */\ngoog.fx.dom.FadeOutAndHide.prototype.onEnd = function() {\n  this.hide();\n  goog.fx.dom.FadeOutAndHide.superClass_.onEnd.call(this);\n};\n\n\n\n/**\n * Sets an element's display to be visible and then fades an element in from\n * completely transparent to fully opaque.\n *\n * @param {Element} element Dom Node to be used in the animation.\n * @param {number} time Length of animation in milliseconds.\n * @param {Function=} opt_acc Acceleration function, returns 0-1 for inputs 0-1.\n * @extends {goog.fx.dom.Fade}\n * @constructor\n * @struct\n */\ngoog.fx.dom.FadeInAndShow = function(element, time, opt_acc) {\n  goog.fx.dom.FadeInAndShow.base(\n      this, 'constructor', element, 0, 1, time, opt_acc);\n};\ngoog.inherits(goog.fx.dom.FadeInAndShow, goog.fx.dom.Fade);\n\n\n/** @override */\ngoog.fx.dom.FadeInAndShow.prototype.onBegin = function() {\n  this.show();\n  goog.fx.dom.FadeInAndShow.superClass_.onBegin.call(this);\n};\n\n\n\n/**\n * Provides a transformation of an elements background-color.\n *\n * Start and End should be 3D arrays representing R,G,B\n *\n * @param {Element} element Dom Node to be used in the animation.\n * @param {Array<number>} start 3D Array for RGB of start color.\n * @param {Array<number>} end 3D Array for RGB of end color.\n * @param {number} time Length of animation in milliseconds.\n * @param {Function=} opt_acc Acceleration function, returns 0-1 for inputs 0-1.\n * @extends {goog.fx.dom.PredefinedEffect}\n * @constructor\n * @struct\n */\ngoog.fx.dom.BgColorTransform = function(element, start, end, time, opt_acc) {\n  if (start.length != 3 || end.length != 3) {\n    throw new Error('Start and end points must be 3D');\n  }\n  goog.fx.dom.BgColorTransform.base(\n      this, 'constructor', element, start, end, time, opt_acc);\n};\ngoog.inherits(goog.fx.dom.BgColorTransform, goog.fx.dom.PredefinedEffect);\n\n\n/**\n * Animation event handler that will set the background-color of an element\n */\ngoog.fx.dom.BgColorTransform.prototype.setColor = function() {\n  var coordsAsInts = [];\n  for (var i = 0; i < this.coords.length; i++) {\n    coordsAsInts[i] = Math.round(this.coords[i]);\n  }\n  var color = 'rgb(' + coordsAsInts.join(',') + ')';\n  this.element.style.backgroundColor = color;\n};\n\n\n/** @override */\ngoog.fx.dom.BgColorTransform.prototype.updateStyle = function() {\n  this.setColor();\n};\n\n\n/**\n * Fade elements background color from start color to the element's current\n * background color.\n *\n * Start should be a 3D array representing R,G,B\n *\n * @param {Element} element Dom Node to be used in the animation.\n * @param {Array<number>} start 3D Array for RGB of start color.\n * @param {number} time Length of animation in milliseconds.\n * @param {goog.events.EventHandler=} opt_eventHandler Optional event handler\n *     to use when listening for events.\n */\ngoog.fx.dom.bgColorFadeIn = function(element, start, time, opt_eventHandler) {\n  var initialBgColor = element.style.backgroundColor || '';\n  var computedBgColor = goog.style.getBackgroundColor(element);\n  var end;\n\n  if (computedBgColor && computedBgColor != 'transparent' &&\n      computedBgColor != 'rgba(0, 0, 0, 0)') {\n    end = goog.color.hexToRgb(goog.color.parse(computedBgColor).hex);\n  } else {\n    end = [255, 255, 255];\n  }\n\n  var anim = new goog.fx.dom.BgColorTransform(element, start, end, time);\n\n  function setBgColor() { element.style.backgroundColor = initialBgColor; }\n\n  if (opt_eventHandler) {\n    opt_eventHandler.listen(anim, goog.fx.Transition.EventType.END, setBgColor);\n  } else {\n    goog.events.listen(anim, goog.fx.Transition.EventType.END, setBgColor);\n  }\n\n  anim.play();\n};\n\n\n\n/**\n * Provides a transformation of an elements color.\n *\n * @param {Element} element Dom Node to be used in the animation.\n * @param {Array<number>} start 3D Array representing R,G,B.\n * @param {Array<number>} end 3D Array representing R,G,B.\n * @param {number} time Length of animation in milliseconds.\n * @param {Function=} opt_acc Acceleration function, returns 0-1 for inputs 0-1.\n * @constructor\n * @struct\n * @extends {goog.fx.dom.PredefinedEffect}\n */\ngoog.fx.dom.ColorTransform = function(element, start, end, time, opt_acc) {\n  if (start.length != 3 || end.length != 3) {\n    throw new Error('Start and end points must be 3D');\n  }\n  goog.fx.dom.ColorTransform.base(\n      this, 'constructor', element, start, end, time, opt_acc);\n};\ngoog.inherits(goog.fx.dom.ColorTransform, goog.fx.dom.PredefinedEffect);\n\n\n/**\n * Animation event handler that will set the color of an element.\n * @protected\n * @override\n */\ngoog.fx.dom.ColorTransform.prototype.updateStyle = function() {\n  var coordsAsInts = [];\n  for (var i = 0; i < this.coords.length; i++) {\n    coordsAsInts[i] = Math.round(this.coords[i]);\n  }\n  var color = 'rgb(' + coordsAsInts.join(',') + ')';\n  this.element.style.color = color;\n};\n","~:compiled-at",1598576858599,"~:source-map-json","{\n\"version\":3,\n\"file\":\"goog.fx.dom.js\",\n\"lineCount\":410,\n\"mappings\":\"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\",\n\"sources\":[\"goog/fx/dom.js\"],\n\"sourcesContent\":[\"// Copyright 2005 The Closure Library Authors. All Rights Reserved.\\n//\\n// Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n// you may not use this file except in compliance with the License.\\n// You may obtain a copy of the License at\\n//\\n//      http://www.apache.org/licenses/LICENSE-2.0\\n//\\n// Unless required by applicable law or agreed to in writing, software\\n// distributed under the License is distributed on an \\\"AS-IS\\\" BASIS,\\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n// See the License for the specific language governing permissions and\\n// limitations under the License.\\n\\n/**\\n * @fileoverview Predefined DHTML animations such as slide, resize and fade.\\n *\\n * @see ../demos/effects.html\\n */\\n\\ngoog.provide('goog.fx.dom');\\ngoog.provide('goog.fx.dom.BgColorTransform');\\ngoog.provide('goog.fx.dom.ColorTransform');\\ngoog.provide('goog.fx.dom.Fade');\\ngoog.provide('goog.fx.dom.FadeIn');\\ngoog.provide('goog.fx.dom.FadeInAndShow');\\ngoog.provide('goog.fx.dom.FadeOut');\\ngoog.provide('goog.fx.dom.FadeOutAndHide');\\ngoog.provide('goog.fx.dom.PredefinedEffect');\\ngoog.provide('goog.fx.dom.Resize');\\ngoog.provide('goog.fx.dom.ResizeHeight');\\ngoog.provide('goog.fx.dom.ResizeWidth');\\ngoog.provide('goog.fx.dom.Scroll');\\ngoog.provide('goog.fx.dom.Slide');\\ngoog.provide('goog.fx.dom.SlideFrom');\\ngoog.provide('goog.fx.dom.Swipe');\\n\\ngoog.forwardDeclare('goog.events.EventHandler');\\ngoog.require('goog.color');\\ngoog.require('goog.events');\\ngoog.require('goog.fx.Animation');\\ngoog.require('goog.fx.Transition');\\ngoog.require('goog.style');\\ngoog.require('goog.style.bidi');\\n\\n\\n\\n/**\\n * Abstract class that provides reusable functionality for predefined animations\\n * that manipulate a single DOM element\\n *\\n * @param {Element} element Dom Node to be used in the animation.\\n * @param {Array<number>} start Array for start coordinates.\\n * @param {Array<number>} end Array for end coordinates.\\n * @param {number} time Length of animation in milliseconds.\\n * @param {Function=} opt_acc Acceleration function, returns 0-1 for inputs 0-1.\\n * @extends {goog.fx.Animation}\\n * @constructor\\n * @struct\\n */\\ngoog.fx.dom.PredefinedEffect = function(element, start, end, time, opt_acc) {\\n  goog.fx.dom.PredefinedEffect.base(\\n      this, 'constructor', start, end, time, opt_acc);\\n\\n  /**\\n   * DOM Node that will be used in the animation\\n   * @type {Element}\\n   */\\n  this.element = element;\\n\\n  /**\\n   * Whether the element is rendered right-to-left. We cache this here for\\n   * efficiency.\\n   * @private {boolean|undefined}\\n   */\\n  this.rightToLeft_;\\n};\\ngoog.inherits(goog.fx.dom.PredefinedEffect, goog.fx.Animation);\\n\\n\\n/**\\n * Called to update the style of the element.\\n * @protected\\n */\\ngoog.fx.dom.PredefinedEffect.prototype.updateStyle = goog.nullFunction;\\n\\n\\n/**\\n * Whether the DOM element being manipulated is rendered right-to-left.\\n * @return {boolean} True if the DOM element is rendered right-to-left, false\\n *     otherwise.\\n */\\ngoog.fx.dom.PredefinedEffect.prototype.isRightToLeft = function() {\\n  if (this.rightToLeft_ === undefined) {\\n    this.rightToLeft_ = goog.style.isRightToLeft(this.element);\\n  }\\n  return this.rightToLeft_;\\n};\\n\\n\\n/** @override */\\ngoog.fx.dom.PredefinedEffect.prototype.onAnimate = function() {\\n  this.updateStyle();\\n  goog.fx.dom.PredefinedEffect.superClass_.onAnimate.call(this);\\n};\\n\\n\\n/** @override */\\ngoog.fx.dom.PredefinedEffect.prototype.onEnd = function() {\\n  this.updateStyle();\\n  goog.fx.dom.PredefinedEffect.superClass_.onEnd.call(this);\\n};\\n\\n\\n/** @override */\\ngoog.fx.dom.PredefinedEffect.prototype.onBegin = function() {\\n  this.updateStyle();\\n  goog.fx.dom.PredefinedEffect.superClass_.onBegin.call(this);\\n};\\n\\n\\n\\n/**\\n * Creates an animation object that will slide an element from A to B.  (This\\n * in effect automatically sets up the onanimate event for an Animation object)\\n *\\n * Start and End should be 2 dimensional arrays\\n *\\n * @param {Element} element Dom Node to be used in the animation.\\n * @param {Array<number>} start 2D array for start coordinates (X, Y).\\n * @param {Array<number>} end 2D array for end coordinates (X, Y).\\n * @param {number} time Length of animation in milliseconds.\\n * @param {Function=} opt_acc Acceleration function, returns 0-1 for inputs 0-1.\\n * @extends {goog.fx.dom.PredefinedEffect}\\n * @constructor\\n * @struct\\n */\\ngoog.fx.dom.Slide = function(element, start, end, time, opt_acc) {\\n  if (start.length != 2 || end.length != 2) {\\n    throw new Error('Start and end points must be 2D');\\n  }\\n  goog.fx.dom.Slide.base(\\n      this, 'constructor', element, start, end, time, opt_acc);\\n};\\ngoog.inherits(goog.fx.dom.Slide, goog.fx.dom.PredefinedEffect);\\n\\n\\n/** @override */\\ngoog.fx.dom.Slide.prototype.updateStyle = function() {\\n  var pos = (this.isRightPositioningForRtlEnabled() && this.isRightToLeft()) ?\\n      'right' :\\n      'left';\\n  this.element.style[pos] = Math.round(this.coords[0]) + 'px';\\n  this.element.style.top = Math.round(this.coords[1]) + 'px';\\n};\\n\\n\\n\\n/**\\n * Slides an element from its current position.\\n *\\n * @param {Element} element DOM node to be used in the animation.\\n * @param {Array<number>} end 2D array for end coordinates (X, Y).\\n * @param {number} time Length of animation in milliseconds.\\n * @param {Function=} opt_acc Acceleration function, returns 0-1 for inputs 0-1.\\n * @extends {goog.fx.dom.Slide}\\n * @constructor\\n * @struct\\n */\\ngoog.fx.dom.SlideFrom = function(element, end, time, opt_acc) {\\n  var offsetLeft = /** @type {!HTMLElement} */ (element).offsetLeft;\\n  var start = [offsetLeft, /** @type {!HTMLElement} */ (element).offsetTop];\\n  goog.fx.dom.SlideFrom.base(\\n      this, 'constructor', element, start, end, time, opt_acc);\\n  /** @type {?Array<number>} */\\n  this.startPoint;\\n};\\ngoog.inherits(goog.fx.dom.SlideFrom, goog.fx.dom.Slide);\\n\\n\\n/** @override */\\ngoog.fx.dom.SlideFrom.prototype.onBegin = function() {\\n  var offsetLeft = this.isRightPositioningForRtlEnabled() ?\\n      goog.style.bidi.getOffsetStart(this.element) :\\n      /** @type {!HTMLElement} */ (this.element).offsetLeft;\\n  this.startPoint = [\\n    offsetLeft,\\n    /** @type {!HTMLElement} */ (this.element).offsetTop\\n  ];\\n  goog.fx.dom.SlideFrom.superClass_.onBegin.call(this);\\n};\\n\\n\\n\\n/**\\n * Creates an animation object that will slide an element into its final size.\\n * Requires that the element is absolutely positioned.\\n *\\n * @param {Element} element Dom Node to be used in the animation.\\n * @param {Array<number>} start 2D array for start size (W, H).\\n * @param {Array<number>} end 2D array for end size (W, H).\\n * @param {number} time Length of animation in milliseconds.\\n * @param {Function=} opt_acc Acceleration function, returns 0-1 for inputs 0-1.\\n * @extends {goog.fx.dom.PredefinedEffect}\\n * @constructor\\n * @struct\\n */\\ngoog.fx.dom.Swipe = function(element, start, end, time, opt_acc) {\\n  if (start.length != 2 || end.length != 2) {\\n    throw new Error('Start and end points must be 2D');\\n  }\\n  goog.fx.dom.Swipe.base(\\n      this, 'constructor', element, start, end, time, opt_acc);\\n\\n  /**\\n   * Maximum width for element.\\n   * @type {number}\\n   * @private\\n   */\\n  this.maxWidth_ = Math.max(this.endPoint[0], this.startPoint[0]);\\n\\n  /**\\n   * Maximum height for element.\\n   * @type {number}\\n   * @private\\n   */\\n  this.maxHeight_ = Math.max(this.endPoint[1], this.startPoint[1]);\\n};\\ngoog.inherits(goog.fx.dom.Swipe, goog.fx.dom.PredefinedEffect);\\n\\n\\n/**\\n * Animation event handler that will resize an element by setting its width,\\n * height and clipping.\\n * @protected\\n * @override\\n */\\ngoog.fx.dom.Swipe.prototype.updateStyle = function() {\\n  var x = this.coords[0];\\n  var y = this.coords[1];\\n  this.clip_(Math.round(x), Math.round(y), this.maxWidth_, this.maxHeight_);\\n  this.element.style.width = Math.round(x) + 'px';\\n  var marginX =\\n      (this.isRightPositioningForRtlEnabled() && this.isRightToLeft()) ?\\n      'marginRight' :\\n      'marginLeft';\\n\\n  this.element.style[marginX] = Math.round(x) - this.maxWidth_ + 'px';\\n  this.element.style.marginTop = Math.round(y) - this.maxHeight_ + 'px';\\n};\\n\\n\\n/**\\n * Helper function for setting element clipping.\\n * @param {number} x Current element width.\\n * @param {number} y Current element height.\\n * @param {number} w Maximum element width.\\n * @param {number} h Maximum element height.\\n * @private\\n */\\ngoog.fx.dom.Swipe.prototype.clip_ = function(x, y, w, h) {\\n  this.element.style.clip =\\n      'rect(' + (h - y) + 'px ' + w + 'px ' + h + 'px ' + (w - x) + 'px)';\\n};\\n\\n\\n\\n/**\\n * Creates an animation object that will scroll an element from A to B.\\n *\\n * Start and End should be 2 dimensional arrays\\n *\\n * @param {Element} element Dom Node to be used in the animation.\\n * @param {Array<number>} start 2D array for start scroll left and top.\\n * @param {Array<number>} end 2D array for end scroll left and top.\\n * @param {number} time Length of animation in milliseconds.\\n * @param {Function=} opt_acc Acceleration function, returns 0-1 for inputs 0-1.\\n * @extends {goog.fx.dom.PredefinedEffect}\\n * @constructor\\n * @struct\\n */\\ngoog.fx.dom.Scroll = function(element, start, end, time, opt_acc) {\\n  if (start.length != 2 || end.length != 2) {\\n    throw new Error('Start and end points must be 2D');\\n  }\\n  goog.fx.dom.Scroll.base(\\n      this, 'constructor', element, start, end, time, opt_acc);\\n};\\ngoog.inherits(goog.fx.dom.Scroll, goog.fx.dom.PredefinedEffect);\\n\\n\\n/**\\n * Animation event handler that will set the scroll position of an element.\\n * @protected\\n * @override\\n */\\ngoog.fx.dom.Scroll.prototype.updateStyle = function() {\\n  if (this.isRightPositioningForRtlEnabled()) {\\n    goog.style.bidi.setScrollOffset(this.element, Math.round(this.coords[0]));\\n  } else {\\n    this.element.scrollLeft = Math.round(this.coords[0]);\\n  }\\n  this.element.scrollTop = Math.round(this.coords[1]);\\n};\\n\\n\\n\\n/**\\n * Creates an animation object that will resize an element between two widths\\n * and heights.\\n *\\n * Start and End should be 2 dimensional arrays\\n *\\n * @param {Element} element Dom Node to be used in the animation.\\n * @param {Array<number>} start 2D array for start width and height.\\n * @param {Array<number>} end 2D array for end width and height.\\n * @param {number} time Length of animation in milliseconds.\\n * @param {Function=} opt_acc Acceleration function, returns 0-1 for inputs 0-1.\\n * @extends {goog.fx.dom.PredefinedEffect}\\n * @constructor\\n * @struct\\n */\\ngoog.fx.dom.Resize = function(element, start, end, time, opt_acc) {\\n  if (start.length != 2 || end.length != 2) {\\n    throw new Error('Start and end points must be 2D');\\n  }\\n  goog.fx.dom.Resize.base(\\n      this, 'constructor', element, start, end, time, opt_acc);\\n};\\ngoog.inherits(goog.fx.dom.Resize, goog.fx.dom.PredefinedEffect);\\n\\n\\n/**\\n * Animation event handler that will resize an element by setting its width and\\n * height.\\n * @protected\\n * @override\\n */\\ngoog.fx.dom.Resize.prototype.updateStyle = function() {\\n  this.element.style.width = Math.round(this.coords[0]) + 'px';\\n  this.element.style.height = Math.round(this.coords[1]) + 'px';\\n};\\n\\n\\n\\n/**\\n * Creates an animation object that will resize an element between two widths\\n *\\n * Start and End should be numbers\\n *\\n * @param {Element} element Dom Node to be used in the animation.\\n * @param {number} start Start width.\\n * @param {number} end End width.\\n * @param {number} time Length of animation in milliseconds.\\n * @param {Function=} opt_acc Acceleration function, returns 0-1 for inputs 0-1.\\n * @extends {goog.fx.dom.PredefinedEffect}\\n * @constructor\\n * @struct\\n */\\ngoog.fx.dom.ResizeWidth = function(element, start, end, time, opt_acc) {\\n  goog.fx.dom.ResizeWidth.base(\\n      this, 'constructor', element, [start], [end], time, opt_acc);\\n};\\ngoog.inherits(goog.fx.dom.ResizeWidth, goog.fx.dom.PredefinedEffect);\\n\\n\\n/**\\n * Animation event handler that will resize an element by setting its width.\\n * @protected\\n * @override\\n */\\ngoog.fx.dom.ResizeWidth.prototype.updateStyle = function() {\\n  this.element.style.width = Math.round(this.coords[0]) + 'px';\\n};\\n\\n\\n\\n/**\\n * Creates an animation object that will resize an element between two heights\\n *\\n * Start and End should be numbers\\n *\\n * @param {Element} element Dom Node to be used in the animation.\\n * @param {number} start Start height.\\n * @param {number} end End height.\\n * @param {number} time Length of animation in milliseconds.\\n * @param {Function=} opt_acc Acceleration function, returns 0-1 for inputs 0-1.\\n * @extends {goog.fx.dom.PredefinedEffect}\\n * @constructor\\n * @struct\\n */\\ngoog.fx.dom.ResizeHeight = function(element, start, end, time, opt_acc) {\\n  goog.fx.dom.ResizeHeight.base(\\n      this, 'constructor', element, [start], [end], time, opt_acc);\\n};\\ngoog.inherits(goog.fx.dom.ResizeHeight, goog.fx.dom.PredefinedEffect);\\n\\n\\n/**\\n * Animation event handler that will resize an element by setting its height.\\n * @protected\\n * @override\\n */\\ngoog.fx.dom.ResizeHeight.prototype.updateStyle = function() {\\n  this.element.style.height = Math.round(this.coords[0]) + 'px';\\n};\\n\\n\\n\\n/**\\n * Creates an animation object that fades the opacity of an element between two\\n * limits.\\n *\\n * Start and End should be floats between 0 and 1\\n *\\n * @param {Element} element Dom Node to be used in the animation.\\n * @param {Array<number>|number} start 1D Array or Number with start opacity.\\n * @param {Array<number>|number} end 1D Array or Number for end opacity.\\n * @param {number} time Length of animation in milliseconds.\\n * @param {Function=} opt_acc Acceleration function, returns 0-1 for inputs 0-1.\\n * @extends {goog.fx.dom.PredefinedEffect}\\n * @constructor\\n * @struct\\n */\\ngoog.fx.dom.Fade = function(element, start, end, time, opt_acc) {\\n  if (typeof start === 'number') start = [start];\\n  if (typeof end === 'number') end = [end];\\n\\n  goog.fx.dom.Fade.base(\\n      this, 'constructor', element, start, end, time, opt_acc);\\n\\n  if (start.length != 1 || end.length != 1) {\\n    throw new Error('Start and end points must be 1D');\\n  }\\n\\n  /**\\n   * The last opacity we set, or -1 for not set.\\n   * @private {number}\\n   */\\n  this.lastOpacityUpdate_ = goog.fx.dom.Fade.OPACITY_UNSET_;\\n};\\ngoog.inherits(goog.fx.dom.Fade, goog.fx.dom.PredefinedEffect);\\n\\n\\n/**\\n * The quantization of opacity values to use.\\n * @private {number}\\n */\\ngoog.fx.dom.Fade.TOLERANCE_ = 1.0 / 0x400;  // 10-bit color\\n\\n\\n/**\\n * Value indicating that the opacity must be set on next update.\\n * @private {number}\\n */\\ngoog.fx.dom.Fade.OPACITY_UNSET_ = -1;\\n\\n\\n/**\\n * Animation event handler that will set the opacity of an element.\\n * @protected\\n * @override\\n */\\ngoog.fx.dom.Fade.prototype.updateStyle = function() {\\n  var opacity = this.coords[0];\\n  var delta = Math.abs(opacity - this.lastOpacityUpdate_);\\n  // In order to keep eager browsers from over-rendering, only update\\n  // on a potentially visible change in opacity.\\n  if (delta >= goog.fx.dom.Fade.TOLERANCE_) {\\n    goog.style.setOpacity(this.element, opacity);\\n    this.lastOpacityUpdate_ = opacity;\\n  }\\n};\\n\\n\\n/** @override */\\ngoog.fx.dom.Fade.prototype.onBegin = function() {\\n  this.lastOpacityUpdate_ = goog.fx.dom.Fade.OPACITY_UNSET_;\\n  goog.fx.dom.Fade.base(this, 'onBegin');\\n};\\n\\n\\n/** @override */\\ngoog.fx.dom.Fade.prototype.onEnd = function() {\\n  this.lastOpacityUpdate_ = goog.fx.dom.Fade.OPACITY_UNSET_;\\n  goog.fx.dom.Fade.base(this, 'onEnd');\\n};\\n\\n\\n/**\\n * Animation event handler that will show the element.\\n */\\ngoog.fx.dom.Fade.prototype.show = function() {\\n  this.element.style.display = '';\\n};\\n\\n\\n/**\\n * Animation event handler that will hide the element\\n */\\ngoog.fx.dom.Fade.prototype.hide = function() {\\n  this.element.style.display = 'none';\\n};\\n\\n\\n\\n/**\\n * Fades an element out from full opacity to completely transparent.\\n *\\n * @param {Element} element Dom Node to be used in the animation.\\n * @param {number} time Length of animation in milliseconds.\\n * @param {Function=} opt_acc Acceleration function, returns 0-1 for inputs 0-1.\\n * @extends {goog.fx.dom.Fade}\\n * @constructor\\n * @struct\\n */\\ngoog.fx.dom.FadeOut = function(element, time, opt_acc) {\\n  goog.fx.dom.FadeOut.base(this, 'constructor', element, 1, 0, time, opt_acc);\\n};\\ngoog.inherits(goog.fx.dom.FadeOut, goog.fx.dom.Fade);\\n\\n\\n\\n/**\\n * Fades an element in from completely transparent to fully opacity.\\n *\\n * @param {Element} element Dom Node to be used in the animation.\\n * @param {number} time Length of animation in milliseconds.\\n * @param {Function=} opt_acc Acceleration function, returns 0-1 for inputs 0-1.\\n * @extends {goog.fx.dom.Fade}\\n * @constructor\\n * @struct\\n */\\ngoog.fx.dom.FadeIn = function(element, time, opt_acc) {\\n  goog.fx.dom.FadeIn.base(this, 'constructor', element, 0, 1, time, opt_acc);\\n};\\ngoog.inherits(goog.fx.dom.FadeIn, goog.fx.dom.Fade);\\n\\n\\n\\n/**\\n * Fades an element out from full opacity to completely transparent and then\\n * sets the display to 'none'\\n *\\n * @param {Element} element Dom Node to be used in the animation.\\n * @param {number} time Length of animation in milliseconds.\\n * @param {Function=} opt_acc Acceleration function, returns 0-1 for inputs 0-1.\\n * @extends {goog.fx.dom.Fade}\\n * @constructor\\n * @struct\\n */\\ngoog.fx.dom.FadeOutAndHide = function(element, time, opt_acc) {\\n  goog.fx.dom.FadeOutAndHide.base(\\n      this, 'constructor', element, 1, 0, time, opt_acc);\\n};\\ngoog.inherits(goog.fx.dom.FadeOutAndHide, goog.fx.dom.Fade);\\n\\n\\n/** @override */\\ngoog.fx.dom.FadeOutAndHide.prototype.onBegin = function() {\\n  this.show();\\n  goog.fx.dom.FadeOutAndHide.superClass_.onBegin.call(this);\\n};\\n\\n\\n/** @override */\\ngoog.fx.dom.FadeOutAndHide.prototype.onEnd = function() {\\n  this.hide();\\n  goog.fx.dom.FadeOutAndHide.superClass_.onEnd.call(this);\\n};\\n\\n\\n\\n/**\\n * Sets an element's display to be visible and then fades an element in from\\n * completely transparent to fully opaque.\\n *\\n * @param {Element} element Dom Node to be used in the animation.\\n * @param {number} time Length of animation in milliseconds.\\n * @param {Function=} opt_acc Acceleration function, returns 0-1 for inputs 0-1.\\n * @extends {goog.fx.dom.Fade}\\n * @constructor\\n * @struct\\n */\\ngoog.fx.dom.FadeInAndShow = function(element, time, opt_acc) {\\n  goog.fx.dom.FadeInAndShow.base(\\n      this, 'constructor', element, 0, 1, time, opt_acc);\\n};\\ngoog.inherits(goog.fx.dom.FadeInAndShow, goog.fx.dom.Fade);\\n\\n\\n/** @override */\\ngoog.fx.dom.FadeInAndShow.prototype.onBegin = function() {\\n  this.show();\\n  goog.fx.dom.FadeInAndShow.superClass_.onBegin.call(this);\\n};\\n\\n\\n\\n/**\\n * Provides a transformation of an elements background-color.\\n *\\n * Start and End should be 3D arrays representing R,G,B\\n *\\n * @param {Element} element Dom Node to be used in the animation.\\n * @param {Array<number>} start 3D Array for RGB of start color.\\n * @param {Array<number>} end 3D Array for RGB of end color.\\n * @param {number} time Length of animation in milliseconds.\\n * @param {Function=} opt_acc Acceleration function, returns 0-1 for inputs 0-1.\\n * @extends {goog.fx.dom.PredefinedEffect}\\n * @constructor\\n * @struct\\n */\\ngoog.fx.dom.BgColorTransform = function(element, start, end, time, opt_acc) {\\n  if (start.length != 3 || end.length != 3) {\\n    throw new Error('Start and end points must be 3D');\\n  }\\n  goog.fx.dom.BgColorTransform.base(\\n      this, 'constructor', element, start, end, time, opt_acc);\\n};\\ngoog.inherits(goog.fx.dom.BgColorTransform, goog.fx.dom.PredefinedEffect);\\n\\n\\n/**\\n * Animation event handler that will set the background-color of an element\\n */\\ngoog.fx.dom.BgColorTransform.prototype.setColor = function() {\\n  var coordsAsInts = [];\\n  for (var i = 0; i < this.coords.length; i++) {\\n    coordsAsInts[i] = Math.round(this.coords[i]);\\n  }\\n  var color = 'rgb(' + coordsAsInts.join(',') + ')';\\n  this.element.style.backgroundColor = color;\\n};\\n\\n\\n/** @override */\\ngoog.fx.dom.BgColorTransform.prototype.updateStyle = function() {\\n  this.setColor();\\n};\\n\\n\\n/**\\n * Fade elements background color from start color to the element's current\\n * background color.\\n *\\n * Start should be a 3D array representing R,G,B\\n *\\n * @param {Element} element Dom Node to be used in the animation.\\n * @param {Array<number>} start 3D Array for RGB of start color.\\n * @param {number} time Length of animation in milliseconds.\\n * @param {goog.events.EventHandler=} opt_eventHandler Optional event handler\\n *     to use when listening for events.\\n */\\ngoog.fx.dom.bgColorFadeIn = function(element, start, time, opt_eventHandler) {\\n  var initialBgColor = element.style.backgroundColor || '';\\n  var computedBgColor = goog.style.getBackgroundColor(element);\\n  var end;\\n\\n  if (computedBgColor && computedBgColor != 'transparent' &&\\n      computedBgColor != 'rgba(0, 0, 0, 0)') {\\n    end = goog.color.hexToRgb(goog.color.parse(computedBgColor).hex);\\n  } else {\\n    end = [255, 255, 255];\\n  }\\n\\n  var anim = new goog.fx.dom.BgColorTransform(element, start, end, time);\\n\\n  function setBgColor() { element.style.backgroundColor = initialBgColor; }\\n\\n  if (opt_eventHandler) {\\n    opt_eventHandler.listen(anim, goog.fx.Transition.EventType.END, setBgColor);\\n  } else {\\n    goog.events.listen(anim, goog.fx.Transition.EventType.END, setBgColor);\\n  }\\n\\n  anim.play();\\n};\\n\\n\\n\\n/**\\n * Provides a transformation of an elements color.\\n *\\n * @param {Element} element Dom Node to be used in the animation.\\n * @param {Array<number>} start 3D Array representing R,G,B.\\n * @param {Array<number>} end 3D Array representing R,G,B.\\n * @param {number} time Length of animation in milliseconds.\\n * @param {Function=} opt_acc Acceleration function, returns 0-1 for inputs 0-1.\\n * @constructor\\n * @struct\\n * @extends {goog.fx.dom.PredefinedEffect}\\n */\\ngoog.fx.dom.ColorTransform = function(element, start, end, time, opt_acc) {\\n  if (start.length != 3 || end.length != 3) {\\n    throw new Error('Start and end points must be 3D');\\n  }\\n  goog.fx.dom.ColorTransform.base(\\n      this, 'constructor', element, start, end, time, opt_acc);\\n};\\ngoog.inherits(goog.fx.dom.ColorTransform, goog.fx.dom.PredefinedEffect);\\n\\n\\n/**\\n * Animation event handler that will set the color of an element.\\n * @protected\\n * @override\\n */\\ngoog.fx.dom.ColorTransform.prototype.updateStyle = function() {\\n  var coordsAsInts = [];\\n  for (var i = 0; i < this.coords.length; i++) {\\n    coordsAsInts[i] = Math.round(this.coords[i]);\\n  }\\n  var color = 'rgb(' + coordsAsInts.join(',') + ')';\\n  this.element.style.color = color;\\n};\\n\"],\n\"names\":[\"goog\",\"provide\",\"forwardDeclare\",\"require\",\"fx\",\"dom\",\"PredefinedEffect\",\"goog.fx.dom.PredefinedEffect\",\"element\",\"start\",\"end\",\"time\",\"opt_acc\",\"base\",\"rightToLeft_\",\"inherits\",\"Animation\",\"prototype\",\"updateStyle\",\"nullFunction\",\"isRightToLeft\",\"goog.fx.dom.PredefinedEffect.prototype.isRightToLeft\",\"undefined\",\"style\",\"onAnimate\",\"goog.fx.dom.PredefinedEffect.prototype.onAnimate\",\"superClass_\",\"call\",\"onEnd\",\"goog.fx.dom.PredefinedEffect.prototype.onEnd\",\"onBegin\",\"goog.fx.dom.PredefinedEffect.prototype.onBegin\",\"Slide\",\"goog.fx.dom.Slide\",\"length\",\"Error\",\"goog.fx.dom.Slide.prototype.updateStyle\",\"pos\",\"isRightPositioningForRtlEnabled\",\"Math\",\"round\",\"coords\",\"top\",\"SlideFrom\",\"goog.fx.dom.SlideFrom\",\"offsetLeft\",\"offsetTop\",\"startPoint\",\"goog.fx.dom.SlideFrom.prototype.onBegin\",\"bidi\",\"getOffsetStart\",\"Swipe\",\"goog.fx.dom.Swipe\",\"maxWidth_\",\"max\",\"endPoint\",\"maxHeight_\",\"goog.fx.dom.Swipe.prototype.updateStyle\",\"x\",\"y\",\"clip_\",\"width\",\"marginX\",\"marginTop\",\"goog.fx.dom.Swipe.prototype.clip_\",\"w\",\"h\",\"clip\",\"Scroll\",\"goog.fx.dom.Scroll\",\"goog.fx.dom.Scroll.prototype.updateStyle\",\"setScrollOffset\",\"scrollLeft\",\"scrollTop\",\"Resize\",\"goog.fx.dom.Resize\",\"goog.fx.dom.Resize.prototype.updateStyle\",\"height\",\"ResizeWidth\",\"goog.fx.dom.ResizeWidth\",\"goog.fx.dom.ResizeWidth.prototype.updateStyle\",\"ResizeHeight\",\"goog.fx.dom.ResizeHeight\",\"goog.fx.dom.ResizeHeight.prototype.updateStyle\",\"Fade\",\"goog.fx.dom.Fade\",\"lastOpacityUpdate_\",\"OPACITY_UNSET_\",\"TOLERANCE_\",\"goog.fx.dom.Fade.prototype.updateStyle\",\"opacity\",\"delta\",\"abs\",\"setOpacity\",\"goog.fx.dom.Fade.prototype.onBegin\",\"goog.fx.dom.Fade.prototype.onEnd\",\"show\",\"goog.fx.dom.Fade.prototype.show\",\"display\",\"hide\",\"goog.fx.dom.Fade.prototype.hide\",\"FadeOut\",\"goog.fx.dom.FadeOut\",\"FadeIn\",\"goog.fx.dom.FadeIn\",\"FadeOutAndHide\",\"goog.fx.dom.FadeOutAndHide\",\"goog.fx.dom.FadeOutAndHide.prototype.onBegin\",\"goog.fx.dom.FadeOutAndHide.prototype.onEnd\",\"FadeInAndShow\",\"goog.fx.dom.FadeInAndShow\",\"goog.fx.dom.FadeInAndShow.prototype.onBegin\",\"BgColorTransform\",\"goog.fx.dom.BgColorTransform\",\"setColor\",\"goog.fx.dom.BgColorTransform.prototype.setColor\",\"coordsAsInts\",\"i\",\"color\",\"join\",\"backgroundColor\",\"goog.fx.dom.BgColorTransform.prototype.updateStyle\",\"bgColorFadeIn\",\"goog.fx.dom.bgColorFadeIn\",\"opt_eventHandler\",\"initialBgColor\",\"computedBgColor\",\"getBackgroundColor\",\"hexToRgb\",\"parse\",\"hex\",\"anim\",\"setBgColor\",\"listen\",\"Transition\",\"EventType\",\"END\",\"events\",\"play\",\"ColorTransform\",\"goog.fx.dom.ColorTransform\",\"goog.fx.dom.ColorTransform.prototype.updateStyle\"]\n}\n"]